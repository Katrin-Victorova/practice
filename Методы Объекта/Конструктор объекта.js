// В JavaScript для создания множества однотипных объектов
// (например, пользователей, товаров) используется
// специальный механизм — функции-конструкторы и оператор new.

// Функции-конструкторы — это обычные функции,
// которые предназначены для создания новых объектов.
// Они позволяют многократно создавать однотипные объекты
// с различными параметрами.

// По соглашению, имя функции-конструктора начинается с заглавной буквы.
// Функции-конструкторы вызываются только с оператором new.

// new Создаёт новый пустой объект.
// Присваивает этот объект переменной ​​​​this​​​​.
// Выполняет код функции, добавляя свойства и методы к объекту.
// Возвращает этот объект.
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

console.log(user.name); // Выведет: Jack
console.log(user.isAdmin); // Выведет: false

// ​​​​User​​​​ — функция-конструктор, которая создает объект
// пользователя с именем ​​​​name​​​​ и свойством ​​​​isAdmin​​​​.

// Когда мы вызываем ​​​​new User("Jack")​​​​, создаётся новый объект,
// и в его свойства записываются переданные данные.

function KserNam(name) {
  // this = {};  (неявно создаётся пустой объект)

  // добавляем свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно возвращается объект this)
}
// Таким образом, вызов new User("Jack") аналогичен следующему коду:
let userUp = {
  name: "Jack",
  isAdmin: false,
};

// Использование конструкторов удобно, когда нужно создать множество
// объектов с одинаковой структурой, но с разными данными.
// Например, создавая пользователей, товары, статьи и т.д.

// Вместо создания каждого объекта вручную, можно вызывать
// конструктор с нужными параметрами:
let user1 = new User("Ann");
let user2 = new User("Alice");

console.log(user1.name); // Ann
console.log(user2.name); // Alice

// Обычно конструкторы не используют оператор return. Однако,
// если в конструкторе есть return, это работает следующим образом:

// Если ​​​​return​​​​ возвращает объект, то этот объект заменит ​​​​this​​​​.

// Если возвращается примитив (число, строка, и т.д.),
// то он игнорируется, и всё равно вернётся ​​​​this​​​​.

// Пример с возвратом объекта:
function BigUser() {
  this.name = "John";
  return { name: "Godzilla" }; // заменяет this
}

let user3 = new BigUser();
console.log(user3.name); // Godzilla

// Пример с возвратом примитива (игнорируется):
function SmallUser() {
  this.name = "John";
  return; // возвращает this
}

let user44 = new SmallUser();
console.log(user44.name); // John

// Создание методов внутри конструктора
// В функции-конструкторе можно не только добавлять свойства,
// но и методы. Методы определяются как обычные функции внутри
// конструктора и привязываются к объекту через this.
function User5(name) {
  this.name = name;

  this.sayHi = function () {
    console.log("Привет, меня зовут " + this.name);
  };
}

let john = new User5("John");
john.sayHi(); // Привет, меня зовут John

// Объект, созданный с помощью конструктора, будет выглядеть так:
// {
//   name: "John",
//   sayHi: function() { ... }
// }

// Функция может узнать, была ли она вызвана с оператором new, 
// используя специальное свойство new.target.
// Если функция вызвана с new, new.target указывает на саму функцию.
// Если без new, new.target будет undefined.
function User7() {
  console.log(new.target); 
}

User7();          // undefined (вызов без new)
new User();      // function User { ... } (вызов с new)

// Мы можем использовать это, чтобы сделать вызов функции с new обязательным:
function User9(name) {
  if (!new.target) {
    return new User9(name); // если вызвали без new, добавляем его
  }
  this.name = name;
}

let userses = User("Jack");  // автоматически добавит new
console.log(userses.name);   // Jack

// Опциональная цепочка ?. — это синтаксическая конструкция, 
// которая позволяет безопасно обращаться к свойствам объектов, 
// не вызывая ошибок, если промежуточные свойства или объекты 
// отсутствуют (равны null или undefined).

// Часто в программах необходимо обращаться к вложенным свойствам объектов. 
// Однако, если одно из свойств на пути доступа не существует, это приведет к ошибке.
let user88 = {}; // пользователь без адреса

alert(user88.address.street); // Ошибка!
// Так как свойства address нет, JavaScript выбросит ошибку 
// при попытке доступа к user.address.street.

// Опциональная цепочка решает эту проблему. Она проверяет, существует ли объект 
// или свойство перед ?.. Если объект или свойство отсутствует 
// (т.е. равно null или undefined), выражение вернет undefined, не выбрасывая ошибку.
let user90 = {}; // пользователь без адреса

alert(user90?.address?.street); // undefined (ошибки нет)
// В этом примере, если объект user или его свойство address 
// не существуют, результатом будет undefined, а не ошибка.

// Работа опциональной цепочки
// Работает как обычный доступ ​​​​value.prop​​​​, если ​​​​value​​​​ существует.
// Возвращает ​​​​undefined​​​​, если ​​​​value​​​​ равно ​​​​null​​​​ или ​​​​undefined​​​​.
let user24 = {
  address: 'Lenina',
};

alert(user24?.address); // 'Lenina'

alert(user24?.address?.street); // undefined
alert(user24?.address.street); // Ошибка!

alert(user24?.phone); // undefined

// Синтаксис ?. можно использовать не только для доступа к свойствам, 
// но и для вызова функций, методов. Это позволяет безопасно вызывать функции, 
// если они могут не существовать:
let userAdmin = {
  admin() {
    alert("Я админ");
  }
};

let userGuest = {};

userAdmin.admin?.(); // "Я админ"
userGuest.admin?.(); // Ничего не произойдет, ошибки нет
// Здесь ?.() проверяет, существует ли метод admin перед тем, как вызвать его.

// Скобочная нотация ?.[] также поддерживается для доступа к свойствам:
let user111 = {
  firstName: "John"
};

let user222 = null;

let key = "firstName";

alert(user111?.[key]); // "John"
alert(user222?.[key]); // undefined

// Если переменная до ?. не существует (например, null или undefined), 
// вычисления останавливаются, и последующие выражения не выполняются:
let user98 = null;
let x = 0;

user98?.sayHi(x++); // функция не вызовется, и x++ не выполнится

alert(x); // 0