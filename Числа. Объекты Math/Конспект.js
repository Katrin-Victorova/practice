// Два типа чисел

// Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, 
// который также называют «числа с плавающей точкой двойной точности» 
// (double precision floating point numbers).

// BigInt​​​​ числа дают возможность работать с целыми числами произвольной длины.
// работать со значениями более чем (253-1) или менее чем -(253-1).
const a = 1234567890123456789012345678901234567890n; // Литерал BigInt
const b = BigInt(9876543210987654321098765432109876543210); // Конструктор BigInt()

console.log(a); // 1234567890123456789012345678901234567890n
console.log(b); // 9876543210987654321098765432109876543210n

let decimal = 123;  // обычное десятичное число

// Шестнадцатеричная система 
// В этой системе используются цифры от 0 до 9 и буквы от A до F для представления чисел от 0 до 15.
// В JavaScript шестнадцатеричные числа записываются с префиксом 0x
let hex = 0xFF;  // 255 в десятичной системе
console.log(hex);  // выводит: 255

// Двоичная система
// Двоичная система использует только два символа: 0 и 1. 
// В JavaScript двоичные числа записываются с префиксом 0b
let binary = 0b1010;  // 10 в десятичной системе
console.log(binary);  // выводит: 10

// Восьмеричная система 
// В этой системе используются цифры от 0 до 7.
// В JavaScript восьмеричные числа записываются с префиксом 0o
let octal = 0o77;  // 63 в десятичной системе
console.log(octal);  // выводит: 63

// Преобразование чисел в другие системы счисления
// опционально можно передать основание системы счисления (от 2 до 36)
let num = 255;
console.log(num.toString());    // "255" (десятичная система)
console.log(num.toString(16));  // выводит: "ff" (шестнадцатеричное)
console.log(num.toString(2));   // выводит: "11111111" (двоичное)

// Как числа с плавающей точкой работают?
// Числа с плавающей точкой в JavaScript представляются как 64-битные числа:
// 1 бит используется для знака числа.
// 11 битов для экспоненты.
// 52 бита для мантиссы (основной части числа).

// Одним из самых известных примеров потери точности является операция сложения:
console.log(0.1 + 0.2);  // Ожидается 0.3, но получаем 0.30000000000000004

// Как избежать потери точности?
// Использование целых чисел.
const price1 = 100; // вместо $1.00
const price2 = 250; // вместо $2.50
const total = price1 + price2; // 350 (3.50 доллара)

// Округлять можно использовать метод toFixed или toPrecision.
const resulte = (0.1 + 0.2).toFixed(2); // '0.30'

// Округляет число до n знаков после запятой и возвращает строку.
// Если необходимо округлить число и сохранить его как строку 
// с фиксированным количеством десятичных знаков, этот метод отлично подходит.
const nume = 0.1 + 0.2;
console.log(nume.toFixed(2));  // "0.30"

// Возвращает строку, представляющую число с заданной точностью (количеством значащих цифр).
const nuem = 0.1 + 0.2;
console.log(nuem.toPrecision(3));  // "0.300"

// Существуют библиотеки, такие как Big.js, Decimal.js, 
// которые позволяют работать с числами без потери точности.
const Big = require('big.js');
const result = new Big(0.1).plus(0.2).toString();  // '0.3'

// Number.parseInt(string, radix): Преобразует строку в целое число, по аналогии с функцией parseInt.
console.log(Number.parseInt("100px", 10));  // 100

// Number.parseFloat(string): Преобразует строку в число с плавающей точкой, аналогично функции parseFloat.
console.log(Number.parseFloat("10.5em"));  // 10.5

// Number.isInteger(value) Метод проверяет, является ли значение целым числом. 
// Возвращает true для целых чисел и false для всего остального (включая числа с плавающей точкой).
console.log(Number.isInteger(123));   // true
console.log(Number.isInteger(12.34)); // false

// Number.isFinite(value) Метод проверяет, является ли значение конечным числом (не Infinity и не NaN). 
// Это более точная проверка, чем глобальная функция isFinite, так как она не преобразует типы.
console.log(Number.isFinite(123));       // true
console.log(Number.isFinite(Infinity));  // false
console.log(Number.isFinite("123"));     // false (в отличие от глобальной функции)

// Number.isNaN(value) Метод проверяет, является ли значение NaN (не числом). 
// В отличие от глобальной функции isNaN, метод не пытается преобразовать строку или другие типы в число.
console.log(Number.isNaN(NaN));        // true
console.log(Number.isNaN("abc"));      // false (строка не преобразуется в число)

// Определяет, является ли значение не числом (NaN). Возвращает true, если это так.
isNaN("abc");  // true (строка не является числом)
isNaN(123);    // false (123 — это число)
isNaN(NaN);    // true

// Проверяет, является ли значение конечным числом. 
// Возвращает false для Infinity, -Infinity и некорректных числовых значений (например, строк).
isFinite(100);      // true (100 — конечное число)
isFinite(Infinity); // false (бесконечность)
isFinite("123");    // true (строка преобразуется в число)
isFinite("abc");    // false (некорректная строка)

// isNaN и Number.isNaN — это два разных метода в JavaScript для проверки того, 
// является ли значение NaN (Not-a-Number). Они работают по-разному, 
// и это различие важно для точной работы с числами.

// isNaN(value) — это глобальная функция, которая проверяет, является ли значение NaN. 
console.log(isNaN(NaN));           // true
console.log(isNaN(123));           // false
console.log(isNaN("123"));         // false (строка преобразована в число)
console.log(isNaN("Hello"));       // true (строка не может быть преобразована в число)
console.log(isNaN(undefined));     // true (undefined становится NaN)
console.log(isNaN(true));          // false (true преобразуется в 1)
console.log(isNaN(null));          // false (null преобразуется в 0)
// ​​isNaN​​​​ выполняет преобразование типов, прежде чем проверить результат.

// Number.isNaN(value) — это более строгая версия функции. 
// Она не выполняет преобразование типа и возвращает true 
// только тогда, когда значение изначально является NaN. 
// Это делает её поведение более предсказуемым.
console.log(Number.isNaN(NaN));       // true
console.log(Number.isNaN(123));       // false
console.log(Number.isNaN("123"));     // false (строка не преобразуется в число)
console.log(Number.isNaN("Hello"));   // false (строка не является NaN)
console.log(Number.isNaN(undefined)); // false (undefined не является NaN)
console.log(Number.isNaN(true));      // false
console.log(Number.isNaN(null));      // false
// Не преобразует значение в число перед проверкой.
// Работает только с значениями, которые изначально являются ​​​​NaN​​​​.

// ​​​​isNaN(value)​​​​: Преобразует значение в число перед проверкой. 
// Возвращает ​​​​true​​​​ для всего, что может быть преобразовано в ​​​​NaN​​​​.

// ​​​​Number.isNaN(value)​​​​: Строго проверяет, является ли значение 
// ​​​​NaN​​​​ без преобразования типа. Возвращает ​​​​true​​​​ только если значение изначально равно ​​​​NaN​​​​.
console.log(isNaN("Hello"));            // true (преобразуется в NaN)
console.log(Number.isNaN("Hello"));     // false (строка не является NaN)

console.log(isNaN(undefined));          // true (undefined -> NaN)
console.log(Number.isNaN(undefined));   // false (undefined не является NaN)

console.log(isNaN("100px"));            // true ("100px" не число)
console.log(Number.isNaN("100px"));     // false (строка не является NaN)
// Таким образом, Number.isNaN — это предпочтительный способ проверки, 
// если вы хотите избежать преобразования типов и хотите проверять только реальные значения NaN.


// Эти функции используются для преобразования строк в числа.

// Преобразует строку в целое число, останавливаясь на первом нечисловом символе. 
// Если второй аргумент передан, он указывает основание системы счисления (по умолчанию 10).
parseInt("100px");   // 100 (игнорируются символы после числа)
parseInt("0xF", 16); // 15 (шестнадцатеричная система)
parseInt("101", 2);  // 5 (двоичная система)

// Преобразует строку в число с плавающей точкой. 
// Также останавливается на первом нечисловом символе, но сохраняет дробную часть, 
// если она присутствует.
parseFloat("12.34px");  // 12.34 (считано до "px")

// когда нам нужно работать где множество 0 и легко запутаться
let someBigNum = 1e6; // 1 * 1000000;
console.log(someBigNum);

let someLitleNum = 1e-6; // 1 / 1000000;
console.log(someLitleNum);


// Number.EPSILON маленькое число для ожидаемого результата

// Метод toLocaleString() преобразует число в строку, учитывая локаль пользователя.
// код_языка. Например, 'ru' (русский язык), 'de' (немецкий), 'en' (английский). 
// код_языка-код_региона. Например, de-AT (австрийский немецкий), 
// 'en-US' (американский английский), es-AR (аргентинский испанский).
const bigNumber = 100_000_000
console.log(bigNumber.toLocaleString('es',
  { style: 'currency', currency: 'EUR' }))
// 100.000.000,00 €

console.log(bigNumber.toLocaleString('ru',
{ style: 'currency', currency: 'RUB', minimumFractionDigits: 0 }))
// 100 000 000 ₽

// торым аргументом в метод можно передать объект с тонкими настройками форматирования. 
// Например, указать, что форматируемое число — деньги

// Значение NaN используется, чтобы сообщить об операции, результатом которой 
// оказалось не число. В JavaScript существует пять операций, которые могут вернуть NaN:

// ошибка парсинга числа (например, при попытке превратить строку в число parseInt('привет'));
// результат математической операции не находится в поле действительных чисел (например, взятие корня от -1);
// один из операндов в арифметической операции — NaN (5 + NaN);
// результат арифметической операции не определён для переданных операндов (undefined + undefined);
// арифметическая операция со строкой, кроме сложения ('привет' * 5).

// Согласно спецификации NaN не равен самому себе. 

// Для проверки на NaN пользуйтесь функцией Number.isNaN(), 
// которая возвращает true если переданное значение — NaN:
const ressult = NaN

console.log(Number.isNaN(ressult))
// true
