// Замыкание — это функция, которая "запоминает" Лексическое окружение, в котором она была создана, даже если это окружение уже завершило выполнение.

// Лексическое окружение - невидимый объект который есть у любого блока, скрипта или функции

// Когда ты создаёшь функцию внутри другой функции, внутренняя функция может использовать переменные внешней функции даже после того, как внешняя функция уже закончила свою работу.

function makeCounter(start) {
	let count = start;
	return function () {
		return count++;
	};
}

const counter = makeCounter(10);
console.log(counter()); // 10
console.log(counter()); // 11
console.log(counter()); // 12

// Где это полезно?
// * Счётчики, приватные данные (инкапсуляция), функции с памятью о предыдущих вызовах.
// * В колбэках, асинхронных операциях, обработчиках событий.

// Замыкание — это как если бы ты уволился с работы, но забрал с собой ключи от офиса. Теперь можешь зайти туда в любое время, хотя официально тебя уже нет в компании.

//Задача
function createIncrement() {
	let count = 0; // начальное значение счётчика
	function increment() {
		count++; // увеличиваем count на 1
	}

	let message = `Count is ${count}`; // создаём строку message на основе текущего count

	function log() {
		console.log(message); // выводим message в консоль
	}

	return [increment, log]; // возвращаем две функции
}

const [increment, log] = createIncrement(); // получаем две функции (деструктуризация массива)
/**
В реальной жизни аналогия:
Представь, что тебе на почте выдали коробку с двумя предметами:
Первый — ручка
Второй — карандаш
Ты сразу достаёшь ручку в одну руку, карандаш — в другую.
Вот это и есть деструктуризация: сразу "раскладываешь" содержимое коробки по местам.
 */

increment(); // увеличиваем count на 1 (count = 1)
increment(); // увеличиваем count на 1 (count = 2)
increment(); // увеличиваем count на 1 (count = 3)

log(); // Что выведется в консоль?

//  Как изменить код для актуального значения?
// Поместить message в функцию log()
function log() {
	let message = `Count is ${count}`; // теперь строка создаётся при каждом вызове log!
	console.log(message);
}
