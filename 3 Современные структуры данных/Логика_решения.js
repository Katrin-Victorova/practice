/*
Общая последовательность решения простой задачи:

1. Понять задачу словами.
   - Что подаётся на вход?
   - Что требуется получить на выходе?
   - Какие есть граничные условия?

2. Определить формат данных.
   - Какие типы входных данных возможны?
   - Как корректно с ними работать?

3. Разбить решение на шаги.
   - Инициализация
   - Перебор / цикл
   - Обновление состояния
   - Возврат результата

4. Выбрать структуру данных.
   - Где хранить промежуточный результат:
     переменная, массив, объект и т.д.

5. Учесть сложные случаи.
   - Пустые входы
   - Неверные типы
   - Очень большие объёмы данных

6. Реализовать императивно.
   - Инициализация → цикл → обновление → return

7. Проверить на примерах.
   - Обычные случаи
   - Крайние значения

8. Проанализировать эффективность.
   - Временная сложность: O(n), O(1) и т.д.
   - Пространственная сложность
------------------------------------------------

Замечания по оптимизации и корректности:

• Сумма массива:
  - Время: O(n) — оптимально, т.к. нужно пройти все элементы
  - Память: O(1), если не использовать доп. структуры

• Реверс строки:
  - Для больших строк лучше собирать символы в массив
    и затем использовать join(''),
    чтобы избежать проблем с конкатенацией

• Всегда учитывайте предусловия (preconditions):
  - Что гарантирует вызывающая сторона?
  - Что необходимо проверять внутри функции?

• Пишите маленькие чистые функции:
  - Одна функция — одна задача
  - Проще тестировать и переиспользовать
*/

// Представь, что любая простая задача — это конвейер:
// Вход → Проверки → Переменная - накопитель → Цикл → Обновление → Return

function solve(input) {
	// 1) проверка входа
	// 2) стартовое значение результата (накопитель)
	// 3) цикл по данным
	// 4) на каждом шаге обновляем накопитель
	// 5) возвращаем результат
}

// “Накопитель” бывает разный:
// число(count, sum, max)
// строка(result)
// массив(items)
// объект(map)
