// Функциональное программирование от А до Я

// Декларативность - Что хотим получить? - описываем Результат
// Довези из точки А в точку Б

// Императивность - Как хотим получить? - описываем Действие
// нажми на газ, повери пять раз на право и тд.... поверни, остановись

// Чистые функции
// При одинаковых входных параметрах всегда возвращает один и тот же результат
// Не зависят от внешнего состояния и глобальных переменных
// не содержат сайд эффектов

// Иммутабельность (неизменяемость)
// Иммутабельные структуры данных потокобезопасны
// Проще отслеживать жизненный цикл обьекта
// Глубокое копирование с которой можешь уже работать
// Допустим строки по умолчанию неизменяемые
// JavaScript - мультипарадигменный ЯП
// Библиотеки Immer / immutable JS позволяют делать код Иммутабельным

// Функции первого класса
// Обьекты - Массивы, обертки над примитивами, функции, обьекты
// обращаемся с функцией - как с обьектом, который можно вызвать ()

// Функции высшего порядка - большая свобода и гибкость
// Функции которые принимают аргументом или возвращают другую функцию

// Композиция
const doubleSortedArray = compose(doubleNubmers, sortArr, compact) // с право на лево передаеться результат выполнения
// Конвейер
const doubleSortedArra1 = pipe(compact, sortArr, doubleNubmers) // с лево на право передаеться результат выполнения

// Каррирование / Частичное применение
clientHasRole(client) ('ADMIN')('third')('fourth')('fifth')
// На каждый вызов - возвращается новая функция
const add10 = sum(10)
add10(50) //60
// Можем создавать новые функции с меньшим кол-вом аргументов

// Chaining - цепочки при вызове функций

// Функтор - класс типов, для которых определение map и выполняеться ряд правил
x.map(f).map(g) = f(g(x)) // - закон композиции
x.map(value => value) = x // - закон идентичности
// map - примеяет функцию к внутреннему состоянию, сохраняя при этом своб структуру и поведение

// Массив - Функтор можно считать

// Апликативный Функтор
// Но как быть: если мы хотим применить функцию к нескольким функторам?
Maybe.of(5) + Maybe.of(10) // null или undefined
// Applicative functor - функтор, который реализует apply(ap)

// Монады
// Maybe - проверяет код на null / undefined
// Either - условное ветвление / обработка ошибок
// Future - тоже самое что и промисы
// IO monad - монада для сайд эффектов. Отделяем саму операцию от вызова. Запускаем через run()
// Writer / runWriter monad