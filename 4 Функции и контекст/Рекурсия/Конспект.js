/*
Рекурсия — это способ решения задачи, при котором функция
вызывает саму себя.
Идея рекурсии:
- большая задача разбивается на более простые подзадачи
- каждая подзадача решается тем же способом, что и исходная
ВАЖНО:
У любой рекурсии ОБЯЗАТЕЛЬНО должен быть базовый случай.
Базовый случай:
- это условие, при котором функция перестаёт вызывать саму себя
- он останавливает рекурсию
- без него будет бесконечный вызов функции
*/

/*
Стек вызовов (call stack) — это структура данных, в которой
JavaScript хранит информацию о текущих выполняемых функциях.
Как работает стек:
1. Функция вызывается → она кладётся в стек
2. Функция завершает работу → она удаляется из стека
В рекурсии:
- каждый рекурсивный вызов создаёт НОВЫЙ фрейм в стеке
- если базовый случай не достигнут, стек продолжает расти
Если стек переполняется, возникает ошибка:
"Maximum call stack size exceeded"
*/

// 1. БАЗОВЫЙ СЛУЧАЙ → когда мы ОСТАНАВЛИВАЕМСЯ
// 2. РЕКУРСИВНЫЙ ШАГ → уменьшаем задачу и вызываем себя

// Но это же можно представить в виде нескольких последовательных умножений на 2:
// 2^5 = ((((2 * 2) * 2) * 2) * 2)
//
// 1 шаг: 2
// 2 шаг: 2 * 2  (результат 1-го шага * 2)
// 3 шаг: 4 * 2  (результат 2-го шага * 2)
// 4 шаг: 8 * 2  (результат 3-го шага * 2)
// 5 шаг: 16 * 2  (результат 4-го шага * 2)
//
// Для получения нового результата
// мы берём предыдущий и умножаем его на 2.

// При таком представлении всё возведение в степень — это лишь умножение предыдущего результата на 2:
// 2^n = 2^(n-1) * 2
// Значение степени двойки —
// это предыдущее значение, умноженное на 2.

/**
Рекурсия проигрывает циклу в следующем:
Отлаживать рекурсию значительно сложнее, чем цикл, а если функция написана плохо — то и просто читать. Она может приводить к переполнению стека. Особенно это ощутимо в таких языках как JS, где переполнение стека может наступить раньше базового случая с высокой вероятностью. Её выполнение может (хотя необязательно) занимать больше памяти.

Цикл же проигрывает рекурсии в таких вещах:
Его нельзя использовать в функциональном программировании, потому что он императивен.
Циклом гораздо сложнее обходить вложенные структуры данных, например, каталоги файлов.
Результат выполнения рекурсивной функции проще закэшировать, чтобы ускорить выполнение, с циклом это сделать сложнее. При работе с общими ресурсами или асинхронными задачами чаще удобнее использовать рекурсивные функции из-за замыканий.
 */
