/* ======================================================
   PROTOTYPE — ПРАКТИКА И КОНСПЕКТ
   ====================================================== */

/* ------------------------------------------------------
   1. Array.prototype.last()
   Задача:
   Добавить метод last(), который возвращает
   последний элемент массива
------------------------------------------------------ */

// Идея:
// Метод должен быть общим для всех массивов,
// поэтому добавляем его в Array.prototype
// this внутри метода — это массив, на котором его вызвали

Array.prototype.last = function () {
	// length - 1 — индекс последнего элемента
	return this[this.length - 1];
};

const numbers = [10, 20, 30];
console.log(numbers.last()); // 30

/* ------------------------------------------------------
   2. String.prototype.reverse()
   Задача:
   Сделать метод reverse(), который
   возвращает строку в обратном порядке
------------------------------------------------------ */

// Идея:
// Строки в JS неизменяемы,
// поэтому:
// 1. превращаем строку в массив символов
// 2. разворачиваем массив
// 3. собираем строку обратно

String.prototype.reverse = function () {
	return this.split('').reverse().join('');
};

const str = 'JavaScript';
console.log(str.reverse()); // "tpircSavaJ"

/* ------------------------------------------------------
   3. Проверка наследования
   Задача:
   Понять, от каких прототипов
   наследуются массивы и объекты
------------------------------------------------------ */

const arr = [1, 2, 3];
const obj = { a: 1 };

// У массива __proto__ указывает на Array.prototype
console.log(arr.__proto__ === Array.prototype); // true

// У объекта __proto__ указывает на Object.prototype
console.log(obj.__proto__ === Object.prototype); // true

// Важно:
// Array.prototype сам наследуется от Object.prototype

/* ------------------------------------------------------
   4. Object.prototype.keysCount()
   Задача:
   Добавить метод, который считает
   количество СОБСТВЕННЫХ свойств объекта
------------------------------------------------------ */

// ВАЖНО:
// В реальных проектах Object.prototype
// лучше не расширять!
// Здесь — учебный пример

Object.prototype.keysCount = function () {
	// Object.keys возвращает только собственные свойства
	return Object.keys(this).length;
};

const user = { name: 'Alex', age: 30 };
console.log(user.keysCount()); // 2

/* ------------------------------------------------------
   5. Использование встроенных методов прототипов
------------------------------------------------------ */

// Задача 1:
// Взять строку, перевести в верхний регистр
// и взять первые 5 символов

const text = 'hello world';

// toUpperCase — метод String.prototype
// slice — тоже метод String.prototype
const upperFive = text.toUpperCase().slice(0, 5);

console.log(upperFive); // "HELLO"

// Задача 2:
// Отсортировать массив по возрастанию
// и вернуть первый элемент

const nums = [5, 3, 8, 1];

// sort без функции сортирует как строки!
// Поэтому передаём функцию сравнения
const smallest = nums.sort((a, b) => a - b)[0];

console.log(smallest); // 1

/* ------------------------------------------------------
   6. String.prototype.lastChar()
   Задача:
   Добавить метод, который возвращает
   последний символ строки
   + сделать безопасно (без перезаписи)
------------------------------------------------------ */

// Проверяем, существует ли метод,
// чтобы не перезаписать его
if (!String.prototype.lastChar) {
	String.prototype.lastChar = function () {
		return this[this.length - 1];
	};
}

const s1 = 'JavaScript';
const s2 = 'Prototype';

console.log(s1.lastChar()); // "t"
console.log(s2.lastChar()); // "e"

/* ======================================================
   КЛЮЧЕВЫЕ ВЫВОДЫ (коротко):
   - prototype хранит общее поведение
   - this указывает на объект вызова
   - чтение свойства идёт вверх по цепочке
   - запись свойства происходит в сам объект
====================================================== */
