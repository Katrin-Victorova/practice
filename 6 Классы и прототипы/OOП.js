/* =========================================================
   ООП (Object-Oriented Programming)
   ========================================================= */
/*

ООП (Object-Oriented Programming) — это подход к проектированию
кода, при котором программа строится из ОБЪЕКТОВ.

Объект = данные + поведение

Данные  → свойства (state)
Поведение → методы (behavior)

Цель ООП:
- структурировать код
- упростить расширение
- упростить сопровождение
- уменьшить связанность (coupling)
*/

/*
-----------------------------------------------------------
ООП В JAVASCRIPT
-----------------------------------------------------------

В JavaScript ООП реализуется через:
- объекты
- прототипы
- классы (class)
- наследование (extends)
- инкапсуляцию (#, _)

ВАЖНО:
JS — прототипный язык
ООП в JS ≠ классическое ООП (Java / C++)
*/

/*
===========================================================
ОСНОВНЫЕ ПРИНЦИПЫ ООП
===========================================================

1. Инкапсуляция
2. Наследование
3. Полиморфизм
4. Абстракция
5. Композиция (архитектурный принцип)
*/

/*
-----------------------------------------------------------
1. ИНКАПСУЛЯЦИЯ
-----------------------------------------------------------

Инкапсуляция — это:
- объединение данных и методов
- ограничение прямого доступа к состоянию объекта

Идея:
❌ нельзя менять состояние напрямую
✅ можно менять только через методы

Зачем:
- защита от ошибок
- контроль состояния
- предсказуемое поведение
*/

/*
Инкапсуляция в JS достигается через:

1) private поля (#property)
2) protected соглашение (_property)
3) методы-геттеры / сеттеры
*/

/*
#property (приватные поля):

- доступны ТОЛЬКО внутри класса
- не наследуются
- не видны снаружи
- настоящая приватность

Использовать, когда:
✔ важно защитить данные
✔ не предполагается доступ извне
*/

/*
_property (защищённые, условно):

- обычные свойства объекта
- доступ есть
- защита только на уровне договорённости

Использовать, когда:
✔ нужно наследование
✔ нужен доступ в подклассах
*/

/*
-----------------------------------------------------------
2. НАСЛЕДОВАНИЕ
-----------------------------------------------------------

Наследование — это механизм, при котором:
- один класс (дочерний)
- расширяет другой (родительский)

extends:
- создаёт прототипную связь
- дочерний класс получает методы родителя

Цель:
- повторное использование кода
- создание иерархий
*/

/*
super():

- вызывает constructor родителя
- ОБЯЗАТЕЛЕН, если в наследнике есть constructor
- должен вызываться ДО this

Почему:
this не существует, пока родитель не инициализировал объект
*/

/*
Плюсы наследования:
✔ меньше дублирования
✔ логичная иерархия

Минусы:
✖ жёсткая связанность
✖ сложно менять архитектуру
✖ легко переусложнить
*/

/*
-----------------------------------------------------------
3. ПОЛИМОРФИЗМ
-----------------------------------------------------------

Полиморфизм — это:
- один интерфейс
- разное поведение

Проще:
Один и тот же метод
ведёт себя по-разному
в разных классах
*/

/*
Как работает в JS:

- метод вызывается у объекта
- JS ищет метод в prototype
- используется ближайшая реализация

Это позволяет:
✔ писать универсальный код
✔ работать с разными типами одинаково
*/

/*
Пример мышления:

user.getAccessLevel()

НЕ важно:
Admin / Guest / User

Важно:
что у объекта есть этот метод
*/

/*
-----------------------------------------------------------
4. АБСТРАКЦИЯ
-----------------------------------------------------------

Абстракция — это:
- выделение СУТИ объекта
- сокрытие деталей реализации

Класс описывает:
❓ ЧТО объект делает
❌ КАК именно — не важно
*/

/*
Абстракция в JS:

- нет abstract классов как в Java
- используется договорённость
- методы выбрасывают ошибку
- ожидается переопределение

Родитель:
задаёт интерфейс

Наследники:
реализуют детали
*/

/*
Зачем:
✔ упрощает архитектуру
✔ уменьшает когнитивную нагрузку
✔ облегчает поддержку
*/

/*
-----------------------------------------------------------
5. КОМПОЗИЦИЯ
-----------------------------------------------------------

Композиция — это:
- объект СОСТОИТ из других объектов
- вместо наследования

Принцип:
"has a" вместо "is a"

Car HAS Engine
а не
Car IS Engine
*/

/*
Почему композиция часто лучше наследования:

✔ меньше связанности
✔ проще менять реализацию
✔ гибче архитектура
✔ меньше иерархий
*/

/*
Правило:
Если можно НЕ использовать extends — лучше НЕ использовать
*/

/*
-----------------------------------------------------------
6. STATIC, INSTANCEOF, #PRIVATE В ООП
-----------------------------------------------------------

static:
- принадлежит классу
- используется для общей логики
- не зависит от экземпляров

Примеры:
- конфигурация
- фабрики
- утилиты
*/

/*
instanceof:

- проверяет наличие prototype в цепочке
- НЕ проверяет "тип" напрямую

Используется для:
✔ проверки иерархий
✔ защитного кода
*/

/*
#private:

- усиливает инкапсуляцию
- предотвращает неправильное использование
- делает API чище
*/

/*
-----------------------------------------------------------
ЧАСТЫЕ ОШИБКИ В ООП (JS)
-----------------------------------------------------------

❌ забыть вызвать super()
❌ использовать наследование вместо композиции
❌ делать всё public
❌ использовать static для бизнес-логики
❌ путать protected (_) и private (#)
❌ переусложнять иерархии
*/

/*
-----------------------------------------------------------
ИТОГОВАЯ МЕНТАЛЬНАЯ МОДЕЛЬ
-----------------------------------------------------------

ООП — это не классы
ООП — это СПОСОБ МЫШЛЕНИЯ

Вопросы, которые нужно задавать:
- за что отвечает объект?
- кто владеет состоянием?
- кто может его менять?
- можно ли заменить реализацию?
- что будет при расширении?

Если ты задаёшь эти вопросы —
ты пишешь ООП правильно
*/
