/**
 * ============================================================
 * КОНСПЕКТ: Имплементация методов массивов в JavaScript
 * (map / concat / reduce / find) + prototype + this
 * ============================================================
 *
 * Зачем это нужно:
 * - Понять, как работают методы массива "под капотом"
 * - Научиться мыслить циклами, callback-ами и this
 *
 * ------------------------------------------------------------
 * 1) Array.prototype и почему arr.map(...) работает
 * ------------------------------------------------------------
 * У каждого массива есть "прототипная цепочка":
 *
 *   arr ---> Array.prototype ---> Object.prototype ---> null
 *
 * Когда мы пишем:
 *   arr.map(cb)
 *
 * JS делает примерно так:
 * 1) ищет метод "map" в самом объекте arr
 * 2) не находит
 * 3) идёт в Array.prototype и находит там map
 * 4) вызывает map так, что внутри него this === arr
 *
 * Поэтому, если мы добавим свой метод:
 *   Array.prototype.myMap = function(cb) {...}
 * то он появится у всех массивов:
 *   [1,2,3].myMap(...)
 *
 * Важно: для методов, где нужен this, используем function,
 * потому что стрелка НЕ имеет своего this.
 *
 * ------------------------------------------------------------
 * 2) Callback в методах массива
 * ------------------------------------------------------------
 * Почти все методы массива принимают callback вида:
 *   (element, index, array) => ...
 *
 * - element: текущий элемент
 * - index: индекс текущего элемента
 * - array: исходный массив (тот же самый)
 *
 * ------------------------------------------------------------
 * 3) MAP
 * ------------------------------------------------------------
 * Что делает map:
 * - проходит по массиву
 * - применяет callback к каждому элементу
 * - собирает результаты в НОВЫЙ массив
 * - НЕ мутирует исходный массив
 *
 * Пример:
 *   [1,2,3].map(x => x*2) -> [2,4,6]
 *
 * Реализация как функция:
 */
function myMap(cb, arr) {
	const res = [];
	for (let i = 0; i < arr.length; i++) {
		res.push(cb(arr[i], i, arr));
	}
	return res;
}

/**
 * Реализация как метод массива:
 */
Array.prototype.myMap = function (callback) {
	const result = [];
	for (let i = 0; i < this.length; i++) {
		result.push(callback(this[i], i, this));
	}
	return result;
};

/**
 * ------------------------------------------------------------
 * 4) CONCAT
 * ------------------------------------------------------------
 * Что делает concat:
 * - склеивает массив с другими массивами/значениями
 * - возвращает НОВЫЙ массив
 * - НЕ мутирует исходный
 *
 * Пример:
 *   [1,2].concat([3,4], [5]) -> [1,2,3,4,5]
 *
 * В наших простых версиях мы склеиваем массивы через spread.
 * (Нативный concat умеет ещё принимать одиночные значения.)
 *
 * Реализация как функция:
 */
function myConcat(array, ...args) {
	let result = [...array]; // копия, чтобы не мутировать исходник

	for (let i = 0; i < args.length; i++) {
		// добавляем элементы args[i] в result
		result = [...result, ...args[i]];
	}

	return result;
}

/**
 * Реализация как метод массива:
 */
Array.prototype.myConcat = function (...args) {
	const result = [...this]; // копируем this (исходный массив)

	for (let i = 0; i < args.length; i++) {
		// push(...массива) добавляет элементы, не создавая новый массив
		result.push(...args[i]);
	}

	return result;
};

/**
 * ------------------------------------------------------------
 * 5) REDUCE (самый важный)
 * ------------------------------------------------------------
 * Что делает reduce:
 * - "сворачивает" массив в ОДНО значение (любого типа)
 * - тип результата зависит от initialValue и того, что возвращаем
 *
 * Сигнатура:
 *   arr.reduce((acc, el, index, arr) => newAcc, initialValue)
 *
 * Главная идея:
 * - acc на следующей итерации = то, что вернули на предыдущей
 *
 * Важный нюанс initialValue:
 * - если initialValue есть: acc = initialValue, старт с индекса 0
 * - если initialValue нет:  acc = arr[0], старт с индекса 1
 * (чтобы не обработать первый элемент дважды)
 *
 * Реализация как функция:
 */
function myReduce(arr, callback, initialValue) {
	const hasInitial = initialValue !== undefined;

	let acc = hasInitial ? initialValue : arr[0];
	let startIndex = hasInitial ? 0 : 1;

	for (let i = startIndex; i < arr.length; i++) {
		acc = callback(acc, arr[i], i, arr);
	}

	return acc;
}

/**
 * Реализация как метод массива:
 */
Array.prototype.myReduce = function (callback, initialValue) {
	const hasInitial = initialValue !== undefined;

	let acc = hasInitial ? initialValue : this[0];
	let startIndex = hasInitial ? 0 : 1;

	for (let i = startIndex; i < this.length; i++) {
		acc = callback(acc, this[i], i, this);
	}

	return acc;
};

/**
 * Пример reduce (делаем объект из массива):
 *   [1,2,3].reduce((acc, el, index) => ({ ...acc, [index]: el }), {})
 *   -> {0:1, 1:2, 2:3}
 *
 * ------------------------------------------------------------
 * 6) FIND
 * ------------------------------------------------------------
 * Что делает find:
 * - возвращает ПЕРВЫЙ элемент, для которого callback вернул true
 * - останавливается сразу на первом совпадении
 * - если ничего не найдено -> undefined
 *
 * Пример:
 *   [1,2,3,4].find(x => x > 2) -> 3
 *
 * Реализация как функция:
 */
function myFind(array, cb) {
	for (let i = 0; i < array.length; i++) {
		const currentItem = array[i];
		if (cb(currentItem, i, array)) {
			return currentItem; // нашли -> сразу выходим
		}
	}
	return undefined; // не нашли
}

/**
 * Реализация как метод массива:
 */
Array.prototype.myFind = function (callback) {
	for (let i = 0; i < this.length; i++) {
		if (callback(this[i], i, this)) {
			return this[i];
		}
	}
	return undefined;
};

/**
 * ------------------------------------------------------------
 * 7) Быстрое сравнение (что возвращают методы)
 * ------------------------------------------------------------
 * map     -> НОВЫЙ массив результатов
 * concat  -> НОВЫЙ массив (склейка)
 * reduce  -> ОДНО значение (любой тип)
 * find    -> ЭЛЕМЕНТ или undefined
 *
 * ------------------------------------------------------------
 * 8) Почему важно помнить про мутацию
 * ------------------------------------------------------------
 * map/concat обычно НЕ меняют исходный массив (возвращают новый)
 * reduce/find тоже не обязаны мутировать (но reduce может, если ты мутируешь acc)
 *
 * ------------------------------------------------------------
 * 9) Важное про стрелки и this
 * ------------------------------------------------------------
 * В Array.prototype.myX лучше писать:
 *   function(...) { ... }
 * потому что:
 *   this -> массив, на котором вызвали метод
 * а у стрелки this берётся "снаружи" и тут обычно ломается.
 *
 * ============================================================
 */
